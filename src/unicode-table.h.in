/**
##header
 */

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

/**
 * Maximum allowed unicode value
 */
#define {c:MAX_VALUE} 0x10FFFF

{if:addFlags}
/**
 * Flags for determining character type
 */
typedef enum {
	{c:FlagLetter}       = 1 << 0,
	{c:FlagUppercase}    = 1 << 1,
	{c:FlagLowercase}    = 1 << 2,
	{c:FlagTitlecase}    = 1 << 3,
	{c:FlagSpace}        = 1 << 4,
	{c:FlagLinebreak}    = 1 << 5,
	{c:FlagPunctuation}  = 1 << 6,
	{c:FlagDigit}        = 1 << 7,
	{c:FlagNumber}       = 1 << 8,
	{c:FlagFraction}     = 1 << 9,
	{c:FlagControl}      = 1 << 10,
	{c:FlagSymbol}       = 1 << 11,
	{c:FlagOther}        = 1 << 12,
	{c:FlagUpperExpands} = 1 << 13,
	{c:FlagLowerExpands} = 1 << 14,
	{c:FlagTitleExpands} = 1 << 15,
} {n:Flag};
{endif:}

{if:addCategories}
/**
 * Character categories
 */
typedef enum {
##categories
} {n:Category};
{endif:}

{if:addCasing}
/**
 * Index usable for `cases` in `{n:Info}`.
 */
typedef enum {
	{c:CaseUpper} = 0,
	{c:CaseLower} = 1,
	{c:CaseTitle} = 2,
} {n:Case};
{endif:}

/**
 * Character info.
 */
typedef struct {
{if:addFlags}
	uint32_t flags;    // flags of `{n:Flag}`
{endif:}
{if:addCategories}
	uint32_t category; // one of `{n:Category}`
{endif:}
{if:addCasing}
	int32_t cases[3];  // indexable with `{n:Case}`
{endif:}
{if:addNumbers}
	union {
		int64_t num;      // number value if `flags & {c:FlagNumber}`
		char const* frac; // fraction string if `flags & {c:FlagFraction}`
	};
{endif:}
} {n:Info};

/**
 * The character.
 */
typedef uint32_t {n:Glyph};

{if:addCasing}
/**
 * Special case-folding characters.
 */
extern {n:Glyph} const {n:SpecialCases}[];
{endif:}

{if:addCategories}
/**
 * Category name indexable with `{n:Category}`.
 */
extern char const* const {n:CategoryNames}[];
{endif:}

/**
 * Lookup character by value.
 */
static inline {n:Info} const* {n:LookupGlyph}({n:Glyph} glyph) {
	extern {n:Info} const {n:Infos}[];
	extern {v:pagesType} const {n:PageIndex}[];
	extern {v:infoType} const {n:InfoIndex}[][256];

	uint32_t page, offset;

	if (glyph > {c:MAX_VALUE}) {
		return &{n:Infos}[0];
	}

	page = {n:PageIndex}[glyph >> 8];
	offset = {n:InfoIndex}[page][glyph & 0xFF];

	return &{n:Infos}[offset];
}

#ifdef __cplusplus
}
#endif
